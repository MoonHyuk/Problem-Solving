# 일일 온도

## 풀이1) 온도 범위가 좁다는 것을 이용

일일 온도의 수 N는 30,000개, 온도의 범위 T은 71이므로 O(NT) 풀이로 풀면 시간 내로 풀 수 있다.

`x[i]` 를 다음과 같이 정의한다.

`x[i]는 온도 i가 등장한 날짜들 중 현재 일자 이후이면서 가장 빠른 날. 그런 날이 존재하지 않는다면 무한대`

예를들어 일일 온도 배열이 `[34, 36, 38, 37, 35, 38, 39]` 이고 현재 날짜가 2이라면(온도가 38도인 날)

`x[37]`은 3, `x[35]`는 4, `x[38]`은 5, `x[39]`는 6이다.

현재 날짜가 1이면 `x[38]`만 2로 바뀐다. (온도가 38도 인 날들은 2, 5가 있지만 그 중 빠른 날은 2 이므로)

현재 날짜를 리스트의 오른쪽에서부터 시작하여 순회하면서

- 현재 날짜의 온도를 Tnow라고 한다면 `min(x[Tnow + 1], x[Tnow + 2], ..., x[100])` (현재 날짜 이후에 현재 날짜보다 온도가 높은 최초의 날)을 구한다.
- 위에서 구한 값이 INF가 아니면 `ans[현재 날짜] = 위에서 구한 값 - 현재 날짜`
- `x[Tnow] = 현재 날짜`



```python
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        INF = 1000000
        
        ans = [0] * len(T)
        x = [INF] * 102
        
        for i in range(len(T) - 1, -1, -1):
            Tnow = T[i]
            
            minDay = min(x[Tnow+1:102])
            
            if minDay != INF:
                ans[i] = minDay - i
            
            x[Tnow] = i
        
        return ans
```



## 풀이2) 스택 이용

스택에 아직 자신보다 높은 온도를 만나지 못한 날들의 인덱스를 넣는다.

예를들어 온도가 `[35, 34, 33, 36]` 이라면 3일이 되기 전까지 스택에는 `[0, 1, 2]` 가 쌓인다.

리스트의 왼쪽에서부터 순회하면서 현재 날짜에 대해

- 스택이 비어있지 않고 스택의 마지막 날짜(`last_day`)의 온도가 현재 온도보다 낮을 동안 `ans[last_day]` 에 현재 날짜와 `last_day` 의 차이를 넣고 스택을 pop 하는 것을 반복한다.

- 반복이 끝나면 현재 날짜를 스택에 넣는다.

스택의 마지막 온도가 현재 온도보다 높으면 스택의 나머지 날짜들은 검사를 하지 않아도 되는데, 스택에 있는 날짜들 중 마지막 날짜의 온도가 가장 낮기 때문이다.

코드를 보면 이중 반복문이지만 위의 이유와 모든 날짜들은 스택에 딱 한번씩 들어가고 빠지기 때문에 시간복잡도는 `O(N)` 이다.

```python
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        ans = [0] * len(T)
        stack = []
        
        for i, t in enumerate(T):
            
            while len(stack) > 0 and T[(last_day := stack[-1])] < t:
                ans[last_day] = i - last_day
                stack.pop()
            
            stack.append(i)
        
        return ans
```

